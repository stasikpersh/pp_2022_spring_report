\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdfpagemode=UseNone,colorlinks,allcolors=black]{hyperref}
\usepackage{tempora}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Поиск кратчайших путей из одной вершины (алгоритм Дейкстры)»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студентка группы 381906-1 \\ Тырина А. К.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\parЗадача о кратчайшем пути — задача поиска самого короткого пути (цепи) между двумя точками (вершинами) на графе, в которой минимизируется сумма весов рёбер, составляющих путь.

Значимость данной задачи определяется её различными практическими применениями. Например, в GPS-навигаторах осуществляется поиск кратчайшего пути между точкой отправления и точкой назначения. В качестве вершин выступают перекрёстки, а дороги являются рёбрами, которые лежат между ними. Если сумма длин дорог между перекрёстками минимальна, тогда найденный путь самый короткий.

Задача о кратчайшем пути является одной из важнейших классических задач теории графов. Сегодня известно множество алгоритмов для её решения. Один из таких алгоритмов - алгоритм Дейкстры, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Алгоритм работает только для графов без рёбер отрицательного веса.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par В данном лабораторной работе требуется реализовать последовательную версию и параллельные версии алгоритма Дейкстры, провести вычислительные эксперименты для сравнения времени работы алгоритмов, используя при этом фрэймворк для разработки автоматических тестов Google Test, сделать выводы об эффективности реализованных алгоритмов.
\par Параллельные алгоритмы должны быть реализованы при помощи библиотек параллельного программирования OpenMP и TBB и встроенных в С++ средств создания потоков std::thread.
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Алгоритм Дейкстры выглядит следующим образом:
\begin{enumerate}
\item Создать множество sptSet (множество дерева наикратчайших путей), которое будет отслеживать вершины, включенные в дерево наикратчайших путей, то есть чьи минимальные расстояния от источника уже посчитаны. Изначально множество пустое.
\item Присвоить значение расстояния всем вершинам во входном графе. Инициализировать все значения расстояний как бесконечность. Присвоить значению расстояния вершины-источника 0, так как мы выбираем её первой.
\item Пока в sptSet не включены все вершины:
  \begin{enumerate}
    \item Выбрать вершину u, которой еще нет в sptSet и у которой значение расстояния минимально.
    \item Включить u в sptSet.
    \item Обновить значения расстояния у всех вершин, смежных u. Чтобы обновить значения расстояний, проитерироваться по всем смежным вершинам. Для каждой смежной вершины v, если сумма значения расстояния u (от источника) и веса ребра u-v меньше, чем значение расстояния v, то обновить значение расстояния v.
  \end{enumerate}
\end{enumerate}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par В нашей программе есть два цикла, которые проходят по всем вершинам - поиск вершины с минимальным расстоянием и обновление смежных вершин. Эти циклы можно распараллелить. Под этим имеется в виду выполнение каждым потоком своей части всего цикла. В OpenMP для этого используется директива parallel for, в TBB - функции parallel\textunderscore reduce и parallel\textunderscore for. Создание потоков и распределение частей циклов в них происходит автоматически. В std::thread мы сами создаем потоки и вручную прописываем, какой поток выполняет какую часть цикла.

\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа состоит из заголовочного файла dijkstra.h и двух файлов исходного кода dijkstra.cpp и main.cpp.
\par В заголовочном файле находятся прототипы функций для последовательного и параллельных алгоритмов Дейкстры.
\par Определения сокращений для типов данных, которые мы используем в программе:
\begin{lstlisting}
using VectorInt = std::vector<int>;
using VectorBool = std::vector<bool>;
using Graph = std::vector<std::vector<int>>;
\end{lstlisting}

\par Функция для создания случайного графа:
\begin{lstlisting}
Graph getRandomGraph(int V);
\end{lstlisting}
Входной параметр - число вершин графа.

\par Последовательная функция алгоритма Дейкстры для нахождения кратчайших путей для одной вершины графа:
\begin{lstlisting}
VectorInt dijkstra(const Graph& graph, int src, int V);
\end{lstlisting}
Функция принимает на вход граф, индекс вершины-источника и количество вершин в графе.

\par Параллельная функция алгоритма Дейкстры для нахождения кратчайших путей для одной вершины графа:
\begin{lstlisting}
VectorInt dijkstra_parallel(const Graph& graph, int src, int V);
\end{lstlisting}
Параметры совпадают с последовательной функцией.

\par Последовательная функция прохода алгоритмом Дейкстры по всем вершинам заданного графа:
\begin{lstlisting}
Graph sequentialDijkstra(const Graph& graph, int V);
\end{lstlisting}
Функция принимает на вход граф и количество его вершин.

\par Параллельная функция прохода алгоритмом Дейкстры по всем вершинам заданного графа (функция совпадает для всех библиотек):
\begin{lstlisting}
Graph parallelDijkstra(const Graph& graph, int V);
\end{lstlisting}
Параметры совпадают с последовательной функцией.

\par В файле исходного кода dijkstra.cpp содержится реализация функций, объявленных в заголовочном файле. В файле исходного кода main.cpp содержатся тесты для проверки корректности программы.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности работы своей программы я написала на фрэймфорке Google Test 5 тестов для каждой версии алгоритма. В каждом тесте я создаю случайный граф, вычисляю результаты работы последовательного и параллельного алгоритмов и сравниваю их, они должны совпадать.
\par Успешное прохождение всех тестов подтверждает корректность работы программы.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Для проведения экспериметов по вычислению эффективности работы разных реализаций программы использовалась система со следующей конфигурацией:
\begin{itemize}
\item Процессор: Intel Core i5-10210U, 1.6 ГГц, ядер: 4, потоков: 8;
\item Оперативная память: 8 ГБ (DDR4), 2666 МГц;
\item Операционная система: Windows 10 Home.
\end{itemize}

\par Эксперименты проводились на 8 потоках. Число вершин в тестовом графе - 20000.

\par Результаты экспериментов представлены в Таблице 1.
\begin{table}[!h]
\centering
\begin{tabular}{| p{4cm} | p{4cm} | p{2cm} |}
\hline
Версия & Время работы (сек.) & Ускорение  \\[5pt]
\hline
Последовательный        & 1.7573        & -         \\
OpenMP        & 0.84735        & 2.07          \\
TBB       & 1.29115        & 1.37         \\
std::thread        & 1.46301        & 1.21           \\
\hline
\end{tabular}
\caption{Результаты экспериментов с графом на 20000 вершин}
\end{table}

\newpage

% Выводы из результатов экспериментов
\section*{Выводы из результатов экспериментов}
\addcontentsline{toc}{section}{Выводы из результатов экспериментов}
Из данных, полученных в результате экспериментов (см. Таблицу 1), можно сделать вывод, что лишь версия с OpenMP позволяет достичь значимого ускорения. Версии с TBB и std::thread дают лишь незначительное ускорение.
\par Это можно связать с тем, что алгоритм Дейкстры заведомо плохо подходит для распараллеливания. В итерациях циклов алгоритма не проводится никаких затратных вычислений, происходит лишь сравнение. Таким образом, даже на больших числах алгоритм работает быстро. Тем временем, задержки на создание потоков, распределение данных и синхронизацию значительно ударяют по общей эффективности. Сильнее всего от этого страдает реализация с std::thread, так как там вся работа с потоками ведется вручную.
\par Тем не менее, можно сказать, что больше всего для создания параллельной версии алгоритма Дейкстры подходит библиотека OpenMP.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
Таким образом, в рамках данной лабораторной работы были разработаны последовательный и три версии параллельного алгоритма Дейкстры. Проведенные тесты показали корректность реализованной программы, а проведенные эксперименты доказали сложности с реализацией параллельного алгоритма Дейкстры.
\newpage

% Литература
\section*{Литература}
\addcontentsline{toc}{section}{Литература}
\begin{enumerate}
\item Wikipedia - Электронный ресурс. URL: \newline \url{https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}
\item Geeksforgeeks - Электронный ресурс. URL: \newline \url{https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/}
\item Educative - Электронный ресурс. URL: \newline \url{https://www.educative.io/blog/modern-multithreading-and-concurrency-in-cpp}
\item А.В. Сысоев, И.Б. Мееров, А.А. Сиднев «Средства разработки параллельных программ для систем с общей памятью. Библиотека Intel Threading Building Blocks». Нижний Новгород, 2007, 128 с. 
\item А.В. Сысоев, И.Б. Мееров, А.Н. Свистунов, А.Л. Курылев, А.В. Сенин, А.В. Шишков, К.В. Корняков, А.А. Сиднев «Параллельное программирование в системах с общей
памятью. Инструментальная поддержка». Нижний Новгород, 2007, 110 с. 
\end{enumerate}


\newpage

\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\subsection*{Последовательный алгоритм Дейкстры}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/seq/dijkstra.h}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/seq/dijkstra.cpp}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/seq/main.cpp}

\subsection*{OpenMP}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/omp/dijkstra.h}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/omp/dijkstra.cpp}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/omp/main.cpp}

\subsection*{TBB}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/tbb/dijkstra.h}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/tbb/dijkstra.cpp}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/tbb/main.cpp}

\subsection*{std::threads}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/std/dijkstra.h}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/std/dijkstra.cpp}
\lstinputlisting[language=C++]{../../modules/task_1/tyrina_a_dijkstra/std/main.cpp}

\end{document}